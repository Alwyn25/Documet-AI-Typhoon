---
description: User-specific preferences and coding patterns for PromptCraft
alwaysApply: true
---

# PromptCraft User Rules

## Personal Coding Preferences

### Code Formatting
- Use 2 spaces for indentation (JavaScript/JSX)
- Use 4 spaces for indentation (Python)
- Maximum line length: 120 characters
- Prefer arrow functions for callbacks
- Use trailing commas in multiline arrays/objects
- Prefer single quotes for strings in JS

### Variable Naming
- Use descriptive, self-documenting names
- Avoid abbreviations except common ones (e.g., `idx`, `max`, `min`)
- Boolean variables should start with `is`, `has`, `should`, `can`
- Event handlers: `handleEventName` or `onEventName`
- Constants: UPPER_SNAKE_CASE

### Function Design
- Keep functions small and focused
- Prefer pure functions when possible
- Use early returns to reduce nesting
- Extract magic numbers and strings to constants
- Document complex algorithms

### Component Patterns
- Functional components with hooks
- Extract logic into custom hooks
- Use composition over inheritance
- Props destructuring at function signature
- Conditional rendering with ternary or &&

### Error Handling Style
- Use try-catch for async operations
- Provide user-friendly error messages
- Log detailed errors for debugging
- Return error objects instead of throwing
- Use error boundaries for React components

### State Management Preferences
- Minimize global state
- Lift state up when needed
- Use reducers for complex state transitions
- Avoid prop drilling; use context carefully
- Prefer Zustand over Context for global state

## Development Workflow

### Task Management
- Break large tasks into small, manageable chunks
- Test incrementally as you build
- Commit frequently with meaningful messages
- Create feature branches for significant changes

### Debugging Approach
- Use console.log sparingly in production code
- Leverage React DevTools for component debugging
- Use browser DevTools for performance profiling
- Add temporary debug flags for troubleshooting
- Remove debug code before committing

### Code Review Process
- Self-review code before submitting PR
- Look for code smells and technical debt
- Check for security vulnerabilities
- Verify accessibility compliance
- Ensure responsive design works

### Documentation Preferences
- Write code that's self-documenting
- Add comments for WHY, not WHAT
- Document complex business logic
- Keep README files current
- Update inline documentation with code changes

## Testing Philosophy

### Manual Testing
- Test happy paths first
- Then test edge cases and error conditions
- Verify UI on multiple browsers
- Check responsive design on various devices
- Test with slow network conditions

### Automated Testing
- Write tests for critical business logic
- Test public APIs thoroughly
- Mock external dependencies
- Keep tests fast and independent
- Update tests when requirements change

### Quality Assurance
- Manual QA before deploying
- Verify cross-browser compatibility
- Test accessibility features
- Check performance benchmarks
- Validate against requirements

## Communication Style

### Commit Messages
- Start with type: feat, fix, docs, style, refactor, test, chore
- Use imperative mood: "Add validation" not "Added validation"
- First line max 72 characters
- Add body for complex changes
- Reference issue numbers when applicable

### Code Comments
- Write comments in plain English
- Explain complex algorithms or business rules
- Mark TODO items for future improvements
- Remove commented-out code before committing
- Use JSDoc for function documentation

### Pull Request Descriptions
- Summarize changes clearly
- Explain WHY changes were made
- List testing performed
- Mention breaking changes
- Include screenshots for UI changes

## Performance Priorities

### Frontend Performance
- Minimize bundle size
- Code split routes and features
- Lazy load images and components
- Debounce expensive operations
- Use virtualization for long lists

### Backend Performance
- Optimize database queries
- Implement proper indexing
- Use connection pooling
- Cache expensive computations
- Profile and optimize bottlenecks

### User Experience
- Minimize loading times
- Show progress indicators
- Implement optimistic UI updates
- Provide offline capabilities
- Handle slow networks gracefully

## Security Practices

### Data Handling
- Sanitize all user inputs
- Validate on both client and server
- Never trust client-side validation alone
- Use parameterized queries
- Implement CSRF protection

### Authentication & Authorization
- Use secure authentication methods
- Implement role-based access control
- Store tokens securely
- Handle token expiration
- Log authentication events

### Secrets Management
- Never commit secrets
- Use environment variables
- Rotate credentials regularly
- Implement secure key storage
- Audit access to sensitive data

## Accessibility Priorities

### Keyboard Navigation
- All interactive elements keyboard accessible
- Logical tab order
- Visible focus indicators
- Skip navigation links
- Keyboard shortcuts for common actions

### Screen Reader Support
- Proper ARIA labels and roles
- Semantic HTML elements
- Descriptive alt text
- Status announcements
- Error announcements

### Visual Accessibility
- Sufficient color contrast
- Text resizable to 200%
- No information conveyed by color alone
- Clear focus indicators
- Responsive and flexible layouts

## Refactoring Guidelines

### When to Refactor
- Before adding complex features
- When code becomes hard to understand
- After removing technical debt
- When performance issues detected
- During code review feedback

### Refactoring Approach
- Refactor in small, incremental steps
- Maintain or improve test coverage
- Keep functionality unchanged
- Review with team before major changes
- Document refactoring decisions

### Code Smell Indicators
- Functions longer than 50 lines
- Deeply nested conditionals
- Repeated code blocks
- Magic numbers and strings
- Tight coupling between modules

## Dependency Management

### Adding Dependencies
- Evaluate necessity carefully
- Check license compatibility
- Review security vulnerabilities
- Assess maintenance status
- Consider bundle size impact

### Updating Dependencies
- Stay current with security patches
- Test thoroughly after updates
- Check breaking changes
- Update dependencies incrementally
- Document reasons for major updates

## Environment Configuration

### Local Development
- Use .env.local for local config
- Mock external services
- Use test databases
- Enable debug logging
- Fast refresh for quick iteration

### Production Deployment
- Strict environment variable checks
- Disable debug logging
- Enable error tracking
- Monitor performance metrics
- Set up automated backups

## Code Style Specifics

### JavaScript/JSX
```javascript
// Prefer const, use let when needed, avoid var
const user = { name: "John" };
let count = 0;

// Arrow functions for callbacks
const handleClick = () => { ... };

// Template literals over concatenation
const message = `Hello, ${user.name}`;

// Destructuring
const { name, email } = user;

// Optional chaining
const phone = user?.contact?.phone;

// Nullish coalescing
const status = user.status ?? 'active';
```

### Python
```python
# Type hints everywhere
def calculate_emi(amount: int, rate: float, tenure: int) -> float:
    ...

# Use f-strings
message = f"User {user.name} logged in"

# List comprehensions
users = [u for u in all_users if u.active]

# Context managers
with open('file.txt') as f:
    ...

# Dataclasses
@dataclass
class User:
    name: str
    email: str
```

## Debugging & Troubleshooting

### Systematic Approach
1. Reproduce the issue consistently
2. Identify the root cause
3. Isolate the problematic code
4. Test the fix thoroughly
5. Document the solution

### Tools & Techniques
- Use browser DevTools effectively
- Leverage React DevTools
- Check network requests
- Review console logs
- Use breakpoints when needed

## Learning & Growth

### Staying Current
- Follow framework release notes
- Read industry best practices
- Experiment with new features
- Share knowledge with team
- Contribute to open source

### Knowledge Sharing
- Document lessons learned
- Create code review guidelines
- Mentor junior developers
- Present findings to team
- Maintain wiki articles

---

**Note**: These are personal preferences that may vary between developers. Team decisions override individual preferences.
